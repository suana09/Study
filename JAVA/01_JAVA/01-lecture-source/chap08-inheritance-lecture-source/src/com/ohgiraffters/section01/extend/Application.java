package com.ohgiraffters.section01.extend;

public class Application {
    public static void main(String[] args) {
        /*상속에 대해 이해할 수 있다.*/
        /*상속은 현실 세계 상속과 비슷한 개념이다.*/
        /*부모가 가지고 있는 재산(자바에서는 클래스가 가지는 멤버) 을 자신이 물려받는다는 의미이다.*/
        /*클래스 또한 부모클래스와 자식클래스로 역할을 나누어서 부모가 가지는 멤버를 자식이 물려받아*/
        /*자기의 멤버인 것처럼 사용할 수 있도록 만든 기술이다.*/

        /*단순히 물려받는 개념보다 조금 더 나아간다면, 자바에서의 상속은*/
        /*부모클래스의 확장 (extend) 의 개념을 가진다*/
        /*물려받아서 자신의 것처럼 사용하는 것 뿐 아니라 추가적인 멤버도 작성이 가능하다.*/
        /*특히, 메소드 재정의 (overriding) 를 이용하여 부모가 가진 메소드를 재정의하는것도 가능하다*/

        /*메소드 재정의(overriding) 이란?*/
        /* 부모가 가지는 메소드 선언부를 그대로 사용하면서 자식 클래스가 정의한 메소드대로 동작하도록 */
        /*구현 몸체 부분을 새롭게 다시 작성하는 기술이다.*/
        /*메소드 재정의를 하면 메소드를 호출할 시 재정의한 메소드가 우선적으로 동작하게 된다.*/

        /*상속을 사용했을 때의 장점은 두 가지가 있다.*/
        /*1. 새로운 클래스를 작성시 기존에 작성한 클래스 재사용 가능*/
        /*  1-1. 재사용으로 생산성 크게 향상시킬 수 있음 (새롭게 작성하는 것보다 빠름)*/
        /*  1-2. 공통적으로 사용하는 코드가 부모클래스에 존재하면 수정사항이 생길 시 부모클래스만 수정해도 됨*/
        /*2. 클래스간의 계층 관계가 형성되며 다형성의 문법적인 토대가 된다.*/

        /*상속으로 인한 단점*/
        /*1. 부모클래스의 기능을 추가, 변경시 자식클래스가 정상 동작하는지 예측이 어려움*/
        /*  상속 구조가 복잡해질수록 그 영향에 대한 예측이 힘들어 이런 단점이 유지보수성이 증가한다는 장점과 반대로 작용*/
        /*  유지보수에 악영향을 미침.*/
        /*2. 또한 부모클래스 변경또한 쉽지X. 자식클래스에서 중요하게 사용하는 기능인 경우 부모클래스를 변경시*/
        /*  자식클래스에 모두 영향을 줄 수 있음. 역시 유지보수에 악영향*/
        /*3. 부모클래스에서는 의미있던 기능들이 자식클래스에서는 무의미할 수 있음 (불필요한 기능이 추가됨)*/

        /*장점과 단점을 고려했을 때 상속은 재사용이라는 장점만을 바라보게 되면 오용의 가능성이 있기 때문에 유지보수에*/
        /*좋지 않은 코드를 작성할 확률이 높다.*/
        /*상속은 IS-A 관계로 구분되는 경우에만 사용해야 한다.*/

        /*객체지향 설계 관점에서 바라보는 상속*/
        /*모든 객체는 자신이 수신한 메세지에 대한 응답을 해야하는 책임을 가지고, 그 책임의 규모는 적절해야한다*/
        /*적절한 책임을 가진 객체들이 서로 협력 (메세지 수신과 응답) 을 통해 프로그램이 동작하는 것을*/
        /*객체지향 프로그램이라고 한다.*/
        /*한 코드에 너무 많은 기능 X*/

        /*적절한 책임을 수행하는 객체 또한 그 객체만 수행할 수 있는 기능이라기보다 역할의 관점으로 바라봐야한다.*/
        /*역할이란 동일한 동작을 수행하는 것을 정의한 것이며, 대체 가능성을 의미한다.*/
        /*부모 클래스를 추상화하는 경우 역할의 관점으로 바라봐야한다*/
        /*그래야 자식클래스로 생성한 객체들이 서로 역할을 수행해가며 유연한 코드를 작성할 수 있게 된다.*/
        /*동일한 역할을 가지는 모든 객체는 동일한 메세지를 수신하기는 하지만 객체별로 그 메세지에 응답하는 방식이*/
        /*서로 다를 수 있다.*/

        Car car = new Car();
        car.soundHorn();
        car.run();
        car.soundHorn();
        car.stop();
        car.soundHorn();

        //생성자와 private 멤버들은 상속X
        //protected 는 상속O
        //자식클래스의 생성자에는 super(); <키워드를 작성해줘야 함
        FireCar fireCar = new FireCar();
        fireCar.soundHorn();
        fireCar.run();
        fireCar.soundHorn();
        fireCar.stop();
        fireCar.soundHorn();

        fireCar.sprayWater();

        RacingCar racingCar = new RacingCar();
        racingCar.soundHorn();
        racingCar.run();
        racingCar.soundHorn();
        racingCar.stop();
        racingCar.soundHorn();

    }
}
